/*
 *  Java
 *
 *  Copyright 2022-2024  MicroEJ Corp. All rights reserved.
 *  Use of this source code is governed by a BSD-style license that can be found with this software.
 *
 */
package com.microej.exercise.ui;

import com.microej.exercise.ui.applicationmenu.ApplicationMenuPage;
import com.microej.exercise.ui.style.Fonts;
import com.microej.exercise.ui.util.Model;
import com.microej.exercise.ui.util.Page;
import com.microej.exercise.ui.watchface.WatchfacePage;
import ej.bon.Util;
import ej.microui.MicroUI;
import ej.microui.display.Colors;
import ej.microui.event.Event;
import ej.microui.event.generator.Command;
import ej.mwt.Desktop;
import ej.mwt.animation.Animator;
import ej.mwt.event.EventDispatcher;
import ej.mwt.event.PointerEventDispatcher;
import ej.mwt.style.EditableStyle;
import ej.mwt.style.background.NoBackground;
import ej.mwt.stylesheet.cascading.CascadingStylesheet;
import ej.mwt.util.Alignment;

/**
 * The entry point of the UI training, based on a simple wearable application with a watchface and a main menu.
 */
public class Main {

	/** Arbitrary application time (in milliseconds since Epoch) for the example purposes. */
	private static final int SOME_DATE = 1648474804;

	private static Desktop desktop;

	/**
	 * Entry point of the application.
	 *
	 * @param args
	 *            command line arguments.
	 */
	public static void main(String[] args) {
		// starts the MicroUI framework
		MicroUI.start();

		// starts the stub business model that will be used across the application
		Model.getInstance().start();

		// sets an arbitrary date and time for the purposes of the training
		Util.setCurrentTimeMillis(SOME_DATE);

		// creates the desktop and show the watchface
		desktop = createDesktop();
		showWatchface();

		// shows the desktop on the display
		desktop.requestShow();
	}

	/**
	 * Shows the given page on the desktop.
	 *
	 * @param page
	 *            the page to show.
	 */
	public static void showPage(Page page) {
		// sets the root widget of the page as the new widget of the desktop
		desktop.setWidget(page.getWidget());

		// populates a stylesheet with the styles for this page and sets it on the desktop
		CascadingStylesheet stylesheet = createStylesheet();
		page.populateStylesheet(stylesheet);
		desktop.setStylesheet(stylesheet);

		// requests the desktop to lay out again to update the display
		desktop.requestLayOut();

		// sets the page as the new observer of changes in the data model (i.e., heart rate, step count, battery)
		Model model = Model.getInstance();
		model.setObserver(page);
	}

	/**
	 * Shows the watchface.
	 */
	public static void showWatchface() {
		showPage(new WatchfacePage());
	}

	/**
	 * Shows the application menu.
	 */
	public static void showApplicationMenu() {
		showPage(new ApplicationMenuPage());
	}

	private static Desktop createDesktop() {
		return new Desktop() {
			@Override
			protected EventDispatcher createEventDispatcher() {
				return newEventDispatcher(this);
			}
		};
	}

	/**
	 * Gets the animator instance to use across the application.
	 *
	 * @return the animator instance to use.
	 */
	public static Animator getAnimator() {
		return desktop.getAnimator();
	}

	private static CascadingStylesheet createStylesheet() {
		CascadingStylesheet stylesheet = new CascadingStylesheet();

		// sets the default style,
		// the attributes of the default style apply to a widget when no more specific rule is set.
		// By default:
		// - the color is white
		// - the background draws nothing (the background is transparent)
		// - the font to use is the medium-sized one
		// - the alignment is horizontally and vertically centered
		EditableStyle style = stylesheet.getDefaultStyle();
		style.setColor(Colors.WHITE);
		style.setBackground(NoBackground.NO_BACKGROUND);
		style.setFont(Fonts.getMediumFont());
		style.setHorizontalAlignment(Alignment.HCENTER);
		style.setVerticalAlignment(Alignment.VCENTER);

		return stylesheet;
	}

	/**
	 * Creates an event dispatcher that can dispatch the pointer events sent by the touch screen and the command events
	 * sent by the physical button.
	 *
	 * @param desktop
	 *            the desktop to bind the event dispatcher to.
	 * @return a new event dispatcher.
	 */
	private static EventDispatcher newEventDispatcher(final Desktop desktop) {
		return new PointerEventDispatcher(desktop) {

			@Override
			public boolean dispatchEvent(int event) {
				// dispatches the events generated by the physical button to the root widget of the desktop
				if (Event.getType(event) == Command.EVENT_TYPE) {
					if (!desktop.getWidget().handleEvent(event)) {
						// the physical button has been pressed, shows the application menu
						Main.showApplicationMenu();
					}
					return true;
				}

				// dispatches the other events (including pointer events)
				return super.dispatchEvent(event);
			}
		};
	}

}
